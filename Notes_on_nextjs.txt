****Creating routes in the app/ directory:********Creating routes in the app/ directory:****
****Creating routes in the app/ directory:********Creating routes in the app/ directory:****

Each folder inside the app/ directory corresponds to a route.
You create a page.tsx file inside the folder to define the content for that route.

my-next-app/
├── app/
│   ├── layout.tsx        # Root layout (applied to all pages)
│   ├── page.tsx          # Corresponds to "/"
│   └── about/
│       └── page.tsx      # Corresponds to "/about"
├── public/
├── styles/
├── next.config.js
└── package.json



***MetaData******MetaData******MetaData******MetaData******MetaData***
***MetaData******MetaData******MetaData******MetaData******MetaData***

https://nextjs.org/docs/app/building-your-application/optimizing/metadata

Page title: What shows up in the browser tab.
Meta description: A short description of the page's content.
Open Graph tags: Used to control how the page looks when shared on social media (like Facebook or Twitter).
Twitter cards: Similar to Open Graph, but specifically for Twitter.
Favicon: The small icon that appears in the browser tab.
Charset and other meta tags.

This can be added to layout.tsx or to top of page.tsx dirreclty

import type { Metadata } from "next";

export const metadata: Metadata = {
  title: "Home Page",
  description: "Generated by create next app",
};



***Error Handiling******Error Handiling******Error Handiling******Error Handiling***
***Error Handiling******Error Handiling******Error Handiling******Error Handiling***

Common: Handle uncaught errors below the root layout with error.js.
Optional: Handle granular uncaught errors with nested error.js files (e.g. app/dashboard/error.js)
Uncommon: Handle uncaught errors in the root layout with global-error.js.


error.tsx
'use client' // Error boundaries must be Client Components
 
import { useEffect } from 'react'
 
export default function Error({
  error,
  reset,
}: {
  error: Error & { digest?: string }
  reset: () => void
}) {
  useEffect(() => {
    // Log the error to an error reporting service
    console.error(error)
  }, [error])
 
  return (
    <div>
      <h2>Something went wrong!</h2>
      <button
        onClick={
          // Attempt to recover by trying to re-render the segment
          () => reset()
        }
      >
        Try again
      </button>
    </div>
  )
}


test this by adding a throw error into page of dirrectory he are handiling error
  throw new Error('Not today')



***Fetching******Fetching******Fetching******Fetching******Fetching******Fetching***
***Fetching******Fetching******Fetching******Fetching******Fetching******Fetching***

https://nextjs.org/docs/app/building-your-application/data-fetching/fetching#reference

1. Static Generation (SSG): Pre-rendering with getStaticProps
When: Data is fetched at build time, and the HTML is generated once during the build process.
Use Case: Use when data doesn’t change often (e.g., blog posts, marketing pages).
Revalidation: You can use the revalidate option to fetch updated data at a specific interval after the page is built.

2. Server-Side Rendering (SSR): Fetching with getServerSideProps
When: Data is fetched on every request, which means the HTML is generated dynamically on the server.
Use Case: Use when data is frequently changing and you need fresh data every time (e.g., user dashboard, live scores).

3. Client-Side Fetching: Fetching in the browser using useEffect or useSWR
When: Data is fetched in the browser after the page has been delivered.
Use Case: Use when SEO is not a priority or the data changes frequently on the client (e.g., user interactions, live updates).
Libraries: You can use useSWR for client-side caching and revalidation.

4. Incremental Static Regeneration (ISR): Rebuilding static pages on demand
When: You can statically generate pages at build time and update them after a certain interval or when requests come in.
Use Case: When you need the benefits of SSG but with some dynamic updates over time.
This is achieved using getStaticProps with the revalidate option.

5. Parallel and Sequential Fetching (with await): Fetching multiple APIs concurrently
When: You may need to fetch multiple APIs in parallel or in sequence to optimize performance.


const Fetch1 = async () => {
    const res = await fetch('http://nbadjangoapplication-env.eba-fpdumciw.us-east-2.elasticbeanstalk.com/api/players/', { cache: 'no-store' });
    const data = await res.json();
  
    return (
      <div>
        <h1>Fetch1 Page</h1>
        <pre>{JSON.stringify(data, null, 2)}</pre>
      </div>
    );
  };
  
  export default Fetch1;